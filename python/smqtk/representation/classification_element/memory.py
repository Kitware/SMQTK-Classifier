from smqtk.representation.classification_element import (
    ClassificationElement,
    NoClassificationError,
)


__author__ = "paul.tunison@kitware.com"


class MemoryClassificationElement (ClassificationElement):
    """
    In-memory representation of classification results. This is represented with
    a python dictionary.
    """

    @classmethod
    def is_usable(cls):
        # No external dependencies
        return True

    def __init__(self, type, uuid):
        """
        Initialize a new in-memory classification element.

        :param type: Name of the type of classifier this classification was
            generated by.
        :type type: str

        :param uuid: Unique ID reference of the classification
        :type uuid: collections.Hashable

        """
        super(MemoryClassificationElement, self).__init__(type, uuid)

        # dictionary of classification labels and values
        #: :type: None | dict[collections.Hashable, float]
        self._c = None

    def get_config(self):
        """
        Return a JSON-compliant dictionary that could be passed to this class's
        ``from_config`` method to produce an instance with identical
        configuration.

        :return: JSON type compliant configuration dictionary.
        :rtype: dict

        """
        return {}

    def has_classifications(self):
        """
        :return: If this element has classification information set.
        :rtype: bool
        """
        return bool(self._c)

    def get_classification(self):
        """
        Get classification result map, returning a label-to-confidence dict.

        We do no place any guarantees on label value types as they may be
        represented in various forms (integers, strings, etc.).

        Confidence values are in the [0,1] range.

        :raises NoClassificationError: No classification labels/confidences yet
            set.

        :return: Label-to-confidence dictionary.
        :rtype: dict[collections.Hashable, float]

        """
        if self._c:
            return self._c
        else:
            raise NoClassificationError("No classification labels/values")

    def set_classification(self, m):
        """
        Set the whole classification map for this element. This will strictly
        overwrite the entire label-confidence mapping (vs. updating it)

        The input map cannot be empty.

        :param m: New labels-to-confidence mapping to set.
        :type m: dict[collections.Hashable]

        :raises EmptyMapError: The given label-confidence map was empty.

        """
        if m:
            self._c = m
        else:
            raise ValueError("Given map was None or empty")
