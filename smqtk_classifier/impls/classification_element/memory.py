from threading import RLock

from smqtk_classifier.exceptions import NoClassificationError
from smqtk_classifier.interfaces.classification_element import ClassificationElement


class MemoryClassificationElement (ClassificationElement):  # lgtm [py/missing-equals]
    """
    In-memory representation of classification results. This is represented
    with a python dictionary.
    """

    __slots__ = ('_c', '_c_lock')

    @classmethod
    def is_usable(cls):
        # No external dependencies
        return True

    def __init__(self, type_name, uuid):
        """
        Initialize a new in-memory classification element.

        :param type_name: Name of the type of classifier this classification
            was generated by.
        :type type_name: str

        :param uuid: Unique ID reference of the classification
        :type uuid: collections.abc.Hashable

        """
        super(MemoryClassificationElement, self).__init__(type_name, uuid)

        # dictionary of classification labels and values
        #: :type: None | dict[collections.abc.Hashable, float]
        self._c = None
        # Cannot be pickled. New lock initialized upon pickle/unpickle
        self._c_lock = RLock()

    def __getstate__(self):
        state = {
            'parent': super(MemoryClassificationElement, self).__getstate__(),
        }
        with self._c_lock:
            state['c'] = self._c
        return state

    def __setstate__(self, state):
        super(MemoryClassificationElement, self).__setstate__(state['parent'])
        if not hasattr(self, '_c_lock') or self._c_lock is None:
            self._c_lock = RLock()
        with self._c_lock:
            #: :type: None | dict[collections.abc.Hashable, float]
            self._c = state['c']

    def get_config(self):
        return {}

    def has_classifications(self):
        with self._c_lock:
            return bool(self._c)

    def get_classification(self):
        with self._c_lock:
            if self._c:
                return self._c
            else:
                raise NoClassificationError("No classification labels/values")

    def set_classification(self, m=None, **kwds):
        m = super(MemoryClassificationElement, self)\
            .set_classification(m, **kwds)
        with self._c_lock:
            self._c = m
